define( [
], function () {
    'use strict';
    var dimensions = {
        uses: "dimensions",
        min: 1,
        type: 'items',
        grouped: true,
        items: {
            dimensionCustomLabel: {
                type: 'items',
                items: {
                    dimensionLabel: {
                        label: 'Custom Label',
                        ref: 'qDef.customLabel',
                        type: 'string',
                        expression: 'optional',
                        defaultValue: ''
                    }
                }
            },
            dimensionCondition: {
                type: 'items',
                items: {
                    visibility: {
                        label: 'Visibility condition',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'qDef.showMeasure',
                        defaultValue: false,
                        options: [{
                            value: true,
                            label: 'Conditional'
                        }, {
                            value: false,
                            label: 'Always'
                        }]
                    },
                    exprCondition: {
                        label: 'Condition',
                        ref: 'qDef.qShowHide',
                        type: 'string',
                        expression: 'optional',
                        defaultValue: '',
                        show: function (obj) {
                            return obj.qDef.showMeasure;
                        }
                    }                    
                }
            },            
            cellWidth: {
                type: 'items',
                items: {
                    adjustColumnWidth: {
                        label: 'Adjust column width',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'qDef.adjustColumnWidth',
                        defaultValue: false,
                        options: [{
                            value: false,
                            label: 'calculated width'
                        }, {
                            value: true,
                            label: 'adjusted width'
                        }]
                    },
                    columnWidthExpr: {
                        label: 'Column width (px)',
                        ref: 'qDef.columnWidth',
                        type: 'number',
                        expression: 'optional',
                        defaultValue: 120,
                        show: function (obj) {
                            return obj.qDef.adjustColumnWidth;
                        },
                        change: function(obj) {return true;}                        
                    }                    
                }
            },
            dimTitleSettings :{
                type: 'items',
                component: 'items',
                items: {
                    cellFontColor: {
                        label: 'Text colour (default)',
                        component: 'color-picker',
                        dualOutput: true,
                        type: 'object',
                        ref: 'qDef.textColorPicker',
                        defaultValue: '',
                        show: function (obj, what) {
                            // console.log('obj', obj); // obj gives you qDef, qAttributeDimensions, qAttributeExpressions, qSortBy
                            // console.log('what', what); // interesting, what gives you dimensionand measure definitions and properties....
                            if (typeof obj.qDef.textColorPicker == 'undefined') {
                                var colour = {
                                    color: 'none',
                                    index: 0
                                };
                                obj.qDef.textColorPicker = colour;
                            }
                            return true;
                        }                           
                    },                     
                    cellFontColorExpression: {
                        label: 'Cell text colour (per cell)',
                        type: 'string',
                        expression: 'optional',
                        component: 'expression',
                        ref: 'qAttributeExpressions.0.qExpression',
                        defaultValue: ''
                    },                      
                    cellBackgroundColor: {
                        label: 'Background colour (default)',
                        component: 'color-picker',
                        dualOutput: true,
                        schemaIgnore: true,
                        type: 'object',
                        ref: 'qDef.backgroundColorPicker',
                        defaultValue: '',
                        show: function (obj, what) {
                            // console.log('obj', obj); // obj gives you qDef, qAttributeDimensions, qAttributeExpressions, qSortBy
                            // console.log('what', what); // interesting, what gives you dimensionand measure definitions and properties....
                            if (typeof obj.qDef.backgroundColorPicker == 'undefined') {
                                var colour = {
                                    color: 'none',
                                    index: 0
                                };
                                obj.qDef.backgroundColorPicker = colour;
                            }
                            return true;
                        }                          
                    },
                    cellBackgroundColorExpression: {
                        label: 'Cell background colour (per cell)',
                        type: 'string',
                        component: 'expression',
                        expression: 'optional',
                        ref: 'qAttributeExpressions.1.qExpression',
                        defaultValue: ''
                    },           
                    titleTextAlignment: {
                        type: 'string',
                        component: 'item-selection-list',
                        icon: true,
                        horizontal: true,
                        label: 'Title horizontal alignment',
                        ref: 'qDef.titleTextAlignment',
                        defaultValue: 'left',
                        items: [{
                            value: 'left',
                            component: 'icon-item',
                            icon: 'M'
                        }, {
                            value: 'center',
                            icon: 'O',
                            component: 'icon-item'
                        }, {
                            value: 'right',
                            icon: 'N',
                            component: 'icon-item'
                        }]                        
                    },                                
                    textAlignment: {
                        type: 'string',
                        component: 'item-selection-list',
                        icon: true,
                        horizontal: true,
                        label: 'Column cell horizontal alignment',
                        ref: 'qDef.textAlignment',
                        defaultValue: 'left',
                        items: [{
                            value: 'left',
                            component: 'icon-item',
                            icon: 'M'
                        }, {
                            value: 'center',
                            icon: 'O',
                            component: 'icon-item'
                        }, {
                            value: 'right',
                            icon: 'N',
                            component: 'icon-item'
                        }]                        
                    }               
                }
            },
            cellBorder: {
                label: 'Show right column border',
                type: 'boolean',
                component: 'switch',
                ref : 'qDef.showBorder',
                defaultValue: true,
                options: [{
                    value: false,
                    label: 'Hide'
                }, {
                    value: true,
                    label: 'Show'
                }]
            },            
            dimensionSelectable: {
                label: 'Selectable when clicked',
                type: 'boolean',
                component: 'switch',
                ref : 'qDef.isSelectable',
                defaultValue: true,
                options: [{
                    value: false,
                    label: 'Not selectable'
                }, {
                    value: true,
                    label: 'Selectable'
                }]
            },
            dimensionSearchable: {
                            label: 'Show search icon',
                            type: 'boolean',
                            component: 'switch',
                            ref : 'qDef.isSearchable',
                            defaultValue: true,
                            options: [{
                                value: false,
                                label: 'Not Searchable'
                            }, {
                                value: true,
                                label: 'Searchable'
                            }]
                        }            
        }        
    };
    var measures = { 
        uses: "measures",
        min: 0,
        type: 'items',
        grouped: true,
        items: {
            measureCustomLabel: {
                type: 'items',
                items: {
                    dimensionLabel: {
                        label: 'Custom Label',
                        ref: 'qDef.customLabel',
                        type: 'string',
                        expression: 'optional',
                        defaultValue: ''
                    }
                }
            },            
            measureCondition: {
                type: 'items',
                items: {
                    visibility: {
                        label: 'Visibility condition',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'qDef.showMeasure',
                        defaultValue: false,
                        options: [{
                            value: true,
                            label: 'Conditional'
                        }, {
                            value: false,
                            label: 'Always'
                        }]
                    },
                    exprCondition: {
                        label: 'Condition',
                        ref: 'qDef.qShowHide',
                        type: 'string',
                        expression: 'optional',
                        defaultValue: '',
                        show: function (obj) {
                            return obj.qDef.showMeasure;
                        }
                    }                    
                }
            },
            titleSettings :{
                type: 'items',
                component: 'items',
                items: {
                    cellFontColor: {
                        label: 'Text colour (default)',
                        component: 'color-picker',
                        dualOutput: true,
                        schemaIgnore: true,
                        type: 'object',
                        ref: 'qDef.textColorPicker',
                        defaultValue: '',
                        show: function (obj, what) {
                            // console.log('obj', obj); // obj gives you qDef, qAttributeDimensions, qAttributeExpressions, qSortBy
                            // console.log('what', what); // interesting, what gives you dimensionand measure definitions and properties....
                            if (typeof obj.qDef.textColorPicker == 'undefined') {
                                var colour = {
                                    color: 'none',
                                    index: 0
                                };
                                obj.qDef.textColorPicker = colour;
                            }
                            return true;
                        }                          
                    },                     
                    cellFontColorExpression: {
                        label: 'Cell text colour (per cell)',
                        type: 'string',
                        expression: 'optional',
                        component: 'expression',
                        ref: 'qAttributeExpressions.0.qExpression',
                        defaultValue: ''
                    },                      
                    cellBackgroundColor: {
                        label: 'Background colour (default)',
                        component: 'color-picker',
                        dualOutput: true,
                        schemaIgnore: true,
                        type: 'object',
                        ref: 'qDef.backgroundColorPicker',
                        defaultValue: '',
                        show: function (obj, what) {
                            // console.log('obj', obj); // obj gives you qDef, qAttributeDimensions, qAttributeExpressions, qSortBy
                            // console.log('what', what); // interesting, what gives you dimensionand measure definitions and properties....
                            if (typeof obj.qDef.backgroundColorPicker == 'undefined') {
                                var colour = {
                                    color: 'none',
                                    index: 0
                                };
                                obj.qDef.backgroundColorPicker = colour;
                            }
                            return true;
                        }                          
                    },
                    cellBackgroundColorExpression: {
                        label: 'Cell background colour (per cell)',
                        type: 'string',
                        expression: 'optional',
                        component: 'expression',
                        ref: 'qAttributeExpressions.1.qExpression',
                        defaultValue: ''
                    },                    
                    titleTextAlignment: {
                        type: 'string',
                        component: 'item-selection-list',
                        icon: true,
                        horizontal: true,
                        label: 'Title horizontal alignment',
                        ref: 'qDef.titleTextAlignment',
                        defaultValue: 'left',
                        items: [{
                            value: 'left',
                            component: 'icon-item',
                            icon: 'M'
                        }, {
                            value: 'center',
                            icon: 'O',
                            component: 'icon-item'
                        }, {
                            value: 'right',
                            icon: 'N',
                            component: 'icon-item'
                        }]                        
                    },                                
                    textAlignment: {
                        type: 'string',
                        component: 'item-selection-list',
                        icon: true,
                        horizontal: true,
                        label: 'Column cell horizontal alignment',
                        ref: 'qDef.textAlignment',
                        defaultValue: 'left',
                        items: [{
                            value: 'left',
                            component: 'icon-item',
                            icon: 'M'
                        }, {
                            value: 'center',
                            icon: 'O',
                            component: 'icon-item'
                        }, {
                            value: 'right',
                            icon: 'N',
                            component: 'icon-item'
                        }]                        
                    }   
                }
            },
            cellWidth: {
                type: 'items',
                items: {
                    adjustColumnWidth: {
                        label: 'Adjust column width',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'qDef.adjustColumnWidth',
                        defaultValue: false,
                        options: [{
                            value: false,
                            label: 'calculated width'
                        }, {
                            value: true,
                            label: 'adjusted width'
                        }]
                    },
                    columnWidthExpr: {
                        label: 'Column width (px)',
                        ref: 'qDef.columnWidth',
                        type: 'number',
                        expression: 'optional',
                        defaultValue: 120,
                        show: function (obj) {
                            return obj.qDef.adjustColumnWidth;
                        },
                        change: function(obj) {return true;}                    
                    }        
                }
            },
            representationSelection: {
                type: 'items',
                items: {
                    representation: {
                        type: 'string',
                        component: 'item-selection-list',
                        icon: true,
                        horizontal: true,
                        label: 'Representation',
                        ref: 'qDef.cellRepresentation',
                        defaultValue: 'text',
                        items: [{
                            value: 'text',
                            component: 'icon-item',
                            labelPlacement: 'bottom',
                            label: 'Text',
                            icon: '/'
                        }, {
                            value: 'progressbar',
                            component: 'icon-item',
                            labelPlacement: 'bottom',
                            label: 'Progress',
                            icon: '⌂'
                        }]
                    },
                    gText: {
                        type: 'items',
                        items: {
                            textisHTML: {
                                type: 'boolean',
                                label: 'Text is HTML',
                                ref: 'qDef.useHTML',
                                defaultValue: false,
                                change: function (obj) {
                                    if (obj.qDef.useHTML) {
                                        obj.qDef.Showtotal = false;
                                        obj.qDef.useURL = false;
                                    }
                                }
                            },
                            textisURL: {
                                type: 'boolean',
                                label: 'Text is URL',
                                ref: 'qDef.useURL',
                                defaultValue: false,
                                change: function (obj) {
                                    if (obj.qDef.useURL) {
                                        obj.qDef.useHTML = false;
                                        obj.qDef.Showtotal = false;
                                    }
                                }
                            },
                            urlLabel: {
                                type: 'string',
                                ref: 'qAttributeExpressions.2.qExpression',
                                component: 'expression',
                                defaultValue: '',
                                label: 'URL Label',
                                show: function (obj) {
                                    return obj.qDef.useURL;
                                }
                            }
                        },
                        show: function (obj) {
                            return obj.qDef.cellRepresentation == 'text';
                        }
                    },                    
                    gprogress: {
                        type: 'items',
                        items: {
                            progressMaxValueSel: {
                                type: 'boolean',
                                component: 'switch',
                                label: 'Progress bar scale',
                                ref: 'qDef.progressMaxIsDynamic',
                                defaultValue: true,
                                trueOption: {
                                    value: true,
                                    label: 'Dynamic'
                                },
                                falseOption: {
                                    value: false,
                                    label: 'Fixed'
                                }
                            },
                            progressMaxValueFixed: {
                                type: 'number',
                                ref: 'qDef.progressMaxFixedValue',
                                expression: 'optional',
                                label: 'Max value',
                                defaultValue: 100,
                                show: function (obj) {
                                    return !obj.qDef.progressMaxIsDynamic;
                                }
                            },
                            progressBarColorPicker: {
                                component: 'color-picker',
                                type: 'object',
                                label: 'Progress bar colour',
                                dualOutput: true,
                                schemaIgnore: true,
                                ref: 'qDef.progressBarColorPicker',
                                show: function (obj, what) {
                                    // console.log('obj', obj); // obj gives you qDef, qAttributeDimensions, qAttributeExpressions, qSortBy
                                    // console.log('what', what); // interesting, what gives you dimensionand measure definitions and properties....
                                    if (typeof obj.qDef.progressBarColorPicker == 'undefined') {
                                        var colour = {
                                            color: 'none',
                                            index: 0
                                        };
                                        obj.qDef.progressBarColorPicker = colour;
                                    }
                                    return true;
                                }                                
                            },
                            progressBarColorExpression: {
                                label: '',
                                type: 'string',
                                expression: 'optional',
                                component: 'expression',
                                ref: 'qAttributeExpressions.3.qExpression',
                                defaultValue: ''
                            },
                            progressBarShowValue: {
                                type: 'boolean',
                                label: 'Show value',
                                ref: 'qDef.progressBarShowValue',
                                defaultValue: false
                            }
                        },
                        show: function (obj) {
                            return obj.qDef.cellRepresentation == 'progressbar';
                        }
                    }
                }
            },
            cellBorder: {
                label: 'Show right column border',
                type: 'boolean',
                component: 'switch',
                ref : 'qDef.showBorder',
                defaultValue: true,
                options: [{
                    value: false,
                    label: 'Hide'
                }, {
                    value: true,
                    label: 'Show'
                }]
            },
            showTotal: {
                label: 'Show Total',
                type: 'boolean',
                ref : 'qDef.Showtotal',
                defaultValue: true,
                change: function(obj) {
                    if (obj.qDef.Showtotal) {
                        obj.qDef.useHTML = false;
                        obj.qDef.useURL = false;
                    }
                }
            }                              
        }
    };
    var sorting = { uses: "sorting" };
    var addons = { uses: "addons" };
    var appearancePanel = { uses: "settings" };
    var tablePanel = {
        type: 'items',
        component: 'expandable-items',        
        label: 'Table settings',
        items: {
            header: {
                label: 'Header',
                component: 'items',
                type: 'items',
                items: {
                    showHeaderRow: {
                        label: 'Show header',
                        type: 'boolean',
                        ref : 'props.header.showHeader',
                        defaultValue: true
                    },                    
                    headerFontColour: {
                        label: 'Font colour',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.header.fontColor',
                        defaultValue: ''
                    },
                    headerFontSize: {
                        label: 'Font Size',
                        type: 'number',
                        expression: 'optional',
                        ref: 'props.header.fontsize',
                        defaultValue: 13,
                        change: function(obj) {}
                    },
                    headerFontFamily: {
                        label: 'Font Family',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.header.fontfamily',
                        defaultValue: ''
                    },
                    headerFontWeight: {
                        label: 'Bold',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'props.header.fontBold',
                        defaultValue: false,
                        options: [{
                            value: false,
                            label: 'Normal'
                        }, {
                            value: true,
                            label: 'Bold'
                        }]
                    },
                    headerFontStyle: {
                        label: 'Italic',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'props.header.fontItalic',
                        defaultValue: false,
                        options: [{
                            value: false,
                            label: 'Normal'
                        }, {
                            value: true,
                            label: 'Italic'
                        }]
                    },
                    headerTextDecoration: {
                        label: 'Underlined',
                        type: 'boolean',
                        component: 'switch',
                        ref : 'props.header.textUnderlined',
                        defaultValue: false,
                        options: [{
                            value: false,
                            label: 'Normal'
                        }, {
                            value: true,
                            label: 'Underlined'
                        }]
                    },  
                    headerBgColour: {
                        label: 'Background colour',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.header.headerBackgroundColor',
                        defaultValue: ''
                    }                                                                                  
                }
            },
            rowSettings: {
                label: 'Rows',
                component: 'items',
                type: 'items',
                items: {
                    rowFontColour: {
                        label: 'Font colour',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.rows.fontColour',
                        defaultValue: ''
                    },
                    rowFontSize: {
                        label: 'Font Size',
                        type: 'number',
                        expression: 'optional',
                        ref: 'props.rows.fontsize',
                        defaultValue: 13,
                        change: function(obj) {}
                    },
                    rowFontFamily: {
                        label: 'Font Family',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.rows.fontfamily',
                        defaultValue: ''
                    },
                    rowFontStyle: {
                        label: 'Font Style',
                        type: 'string',
                        component: 'buttongroup',
                        ref: 'props.rows.fontstyle',
                        defaultValue: '',
                        options: [{
                            value:'bold',
                            label: 'Bold',
                            tooltip: 'Select for bold'
                        },
                        {
                            value:'italic',
                            label: 'Italic',
                            tooltip: 'Select for bold'
                        } ,
                        {
                            value:'underline',
                            label: 'Underline',
                            tooltip: 'Select for bold'
                        }                        ]
                    },
                    rowBgColour: {
                        label: 'Background colour',
                        type: 'string',
                        expression: 'optional',
                        ref: 'props.rows.rowsBackgroundColor',
                        defaultValue: ''
                    }, 
                    showRowBorder: {
                        label: 'Show row border',
                        type: 'boolean',
                        ref : 'props.rows.showBorder',
                        defaultValue: true
                    },
                    showRowStripes: {
                        label: 'Show row stripes',
                        type: 'boolean',
                        ref : 'props.rows.useStripes',
                        defaultValue: true
                    },
                    rowHover: {
                        component: 'items',                
                        type: 'items',                        
                        items: {
                            showRowHover: {
                                label: 'Highlight rows',
                                type: 'boolean',
                                ref : 'props.rows.highlightRows',
                                defaultValue: true
                            },                    
                            rowHoverBgColour: {
                                label: 'Hightlight colour',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.rows.rowHighlightColour',
                                defaultValue: '#696969'
                            },
                            rowHoverFontColour: {
                                label: 'Hightlight font colour',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.rows.rowHoverFontColour',
                                defaultValue: '#FFFFFF'
                            }
                        }
                    }                                                                                                                                                     
                }
            },    
            totals: {
                label: 'Totals',
                component: 'items',                
                type: 'items',
                grouped: true,
                items: {
                    totalSettings: {
                        component: 'items',                
                        type: 'items',                        
                        items: {
                            showTotals: {
                                label: 'Show total row',
                                type: 'boolean',
                                ref : 'props.totals.showTotals',
                                defaultValue: true
                            },    
                            totalsPosition: {
                                label: 'Font Style',
                                type: 'string',
                                component: 'buttongroup',
                                ref: 'props.totals.position',
                                defaultValue: '',
                                options: [{
                                    value:'top',
                                    label: 'Top',
                                    tooltip: 'Select for top'
                                },
                                {
                                    value:'bottom',
                                    label: 'Bottom',
                                    tooltip: 'Select for bottom'
                                }                       ]
                            },                                        
                            totalsBackgroundColor: {
                                label: 'Background colour',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.totals.totalsBackgroundColor',
                                defaultValue: ''
                            },
                            totalsFontColor: {
                                label: 'Text colour',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.totals.totalsTextColor',
                                defaultValue: ''
                            },                            
                            totalsLabel: {
                                label: 'Totals label',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.totals.totalsLabel',
                                defaultValue: ''
                            }
                        }
                    }
                }
            },                  
            other: {
                label: 'Other',
                component: 'items',                
                type: 'items',
                grouped: true,
                items: {
                    nullSettings: {
                        component: 'items',                
                        type: 'items',                        
                        items: {
                            nullsymbol: {
                                label: 'Null symbol',
                                type: 'string',
                                ref : 'props.nullsymbol',
                                defaultValue: ''
                            },                    
                            nullCellBackgroundColor: {
                                label: 'Null cell background colour',
                                type: 'string',
                                expression: 'optional',
                                ref: 'props.nullCellBackgroundColor',
                                defaultValue: ''
                            },
                            maxRowCount: {
                                label: 'Maximum number of rows to display',
                                type: 'number',
                                ref: 'props.maxDisplayRows',
                                expression: 'optional',
                                defaultValue: 500
                            }
                        }
                    },
                    exportSetting: {
                        label: 'Enable exporting as image/PDF',
                        type: 'boolean',
                        ref : 'props.enableExport',
                        defaultValue: false
                    },
                    exportDataSetting: {
                        label: 'Enable exporting of data',
                        type: 'boolean',
                        ref : 'props.enableExportData',
                        defaultValue: false
                    },
                    selectOptions: {
                        label: 'Single click select',
                        type: 'boolean',
                        ref : 'props.standardSelect',
                        defaultValue: false
                    }        
                }
            }
        }
    };
    return {
        type: "items",
        component: "accordion",
        items: {
            dimensions: dimensions,
            measures: measures,
            addons:  {
                uses: 'addons',
                type: 'items',
                component: 'items',                
                items: {
                    zerovalues: {
                        type: 'boolean',
                        ref: 'qHyperCubeDef.qSuppressZero',
                        label: 'Suppress Zero Values',
                        defaultValue: false
                    }
                }
            },            
            sorting: sorting,
            customSection: tablePanel,
            appearance: appearancePanel
        }
    };
} );


define([
], function () {
     'use strict';
    return {
        qHyperCubeDef: {
            qDimensions: [],
            qMeasures: [],
            qInitialDataFetch: [
                {
                    qWidth: 100,
                    qHeight: 100
                }
            ]
        }
    };
} );

define([], function(){
  return {
    extensionMeta: {
      name : 'Calibrate Table',
      description : 'Calibrate Table',
      icon : 'table',
      type : 'visualization',
      version: '0.1.0',
      author: 'Mark Fereday',
      dependencies: {
        'qlik-sense': '>=3.0.x'
      },
      email: 'markfereday@fereday.com',
      homepage: 'fereday.com',
      isLibraryItem: true,
      isThirdParty: true,
      keywords: 'qlik-sense, visualization',
      license: '2017 © CC Ltd. - All rights reserved.',
      preview: 'ccTable.png',
      previewIconURL: '../extensions/ccTableV2/ccTable.png',
      repository: '',
      tc: '',
      template: '',
      templateIconClassName: ''
    }
  }
})

define( [
  'qlik',
  './properties',
  './initialproperties',
  './defaults',  
  'jquery', 
  'text!./template.html',
  'angular',
  'qvangular'
  ],
  function (qlik, props, initProps, defaults, $, htmlTemplate, angular, qvangular) {
    'use strict';
    var _app = qlik.currApp();
    var popUpSvc = qvangular.getService('qvListboxPopoverService');
    
    return {
      definition: props,
      initialProperties: initProps,
      support: {snapshot: true},
      template: htmlTemplate,
      resize: function($element, layout) {
        this.$scope.$parent.component.resizeTable(this.$scope.vm);
      },
      resizeTable: function(vm) {
        var qId = vm.qInfo.qId;
        var table = $('#ccTable_' + qId);
        var head = $('#ccTableHead_' + qId);
        var body = $('#ccTableBody_'  + qId);
        var headHeight = head.length > 0 ? head[0].clientHeight : 40;
        
        console.log('resizeTable', vm);

        if (vm.props.totals.showTotals && vm.props.totals.position === 'bottom') {
          var foot = $('#ccTableFoot_' + qId);
          var headHeight = headHeight + (foot.length > 0 ? foot[0].clientHeight : 0);
        }
        
        var scrollWidth = (body[0].offsetWidth - body[0].clientWidth) < 0 ? 0 : body[0].offsetWidth - body[0].clientWidth;
        
        if (table.length > 0) {
          vm.virtualScroll.sbHeight = table[0].parentElement.clientHeight - headHeight - scrollWidth - 8;
          var h = (vm.virtualScroll.sbHeight) + 'px'; // -8 to allow for horizontal scroll bar
        
          if (h == '0px') {
            body.css('height', '100%');
            vm.virtualScroll.sbHeightpx = '100%';
            vm.virtualScroll.sbHeight = '100';
          } else {    
            body.css('height', h);
            vm.virtualScroll.sbHeightpx = h;
          }
        
          vm.virtualScroll.sbToppx = headHeight + 'px';
          vm.virtualScroll.sbThumbHpx = '20px';
          vm.virtualScroll.sbThumbH = 20;
        }
        
        if (head.length > 0) {
          var scrollWidth = body[0].offsetWidth - body[0].clientWidth;
        
          if (body[0].scrollHeight <= body[0].clientHeight || scrollWidth < 0) {
            head.css('width', '100%');
          } else {
            head.css('width', 'calc(100% - ' + Math.max(0, scrollWidth) + 'px)');
          }
        }
        
        var tableId = '#ccTable_' + vm.qInfo.qId;
        var top  = $(tableId + ' tbody').offset().top;
        var height = $(tableId + ' tbody').height();
        
        var visible = $(tableId + ' tbody tr').filter(function() {
          var elTop  = $(this).offset().top;
          var elHeight = $(this).height();
          var ret = (elTop >= top) && ((elTop + elHeight) < (top + height));
            // if (ret) {
            //   console.log('filteredRow', this);
            //   console.log('elTop', elTop);
            //   console.log('elHeight', elHeight);
            // }
          return ret;
        });
        
        vm.virtualScroll.rowsVisibleCount = visible.length;
        vm.virtualScroll.showScroll = vm.virtualScroll.rowsVisibleCount < vm.qHyperCube.qSize.qcy;
        //console.log('resize: vm.virtualScroll', vm.virtualScroll);
      },
      controller: ['$scope', '$element', function ( $scope, $element ) {
        var currentLayout = {};
        var qId = $scope.layout.qInfo.qId;
        
        $scope.qProductVersion = ''
        
        qlik.getGlobal({}).getProductVersion(function(reply) {
          console.log('getProductVersion: reply', reply)
          $scope.qProductVersion = reply.qReturn;
        })
        
        $scope.component.model.Validated.bind(function() {
          refresh();
        });
        
        $scope.scrollMouseDown = function($event, isThumb) {
          // console.log('scrollMouseDown', 'page: ' + $event.pageX + ' ' + $event.pageY + ' | offset: ' + $event.offsetX + ' ' + $event.offsetY);
          //console.log('scrollMouseDown', $event);
          if ($event.buttons != 1) {
            $scope.tableMouseDown = false;
            return;
          }
          
          $event.preventDefault();
          
          if (!isThumb) {
            $scope.tableMouseDown = false;
            setScrollBarTop($event.offsetY, false, false, false);
          } else {
            $scope.tableMouseDown = true;
          }
        }
        
        $scope.scrollMouseUp = function($event) {
          // console.log('scrollMouseUp', 'page: ' + $event.pageX + ' ' + $event.pageY + ' | offset: ' + $event.offsetX + ' ' + $event.offsetY);
          // console.log('scrollMouseUp', $event);
          if ($event.buttons == 1) {
            $event.preventDefault();
            $scope.tableMouseDown = false;
          }
        }
        
        $scope.scrollMouseMove = function($event) {
          // check button is stil down
          if ($event.buttons != 1) {
            $scope.tableMouseDown = false;
            return;
          }
          if ($scope.tableMouseDown) {
            // console.log('scrollMouseMove', 'page: ' + $event.pageX + ' ' + $event.pageY + ' | offset: ' + $event.offsetX + ' ' + $event.offsetY);
            // console.log('scrollMouseMove', $event);
            setScrollBarTop($event.offsetY, true, false, false);
          }
        }
        
        function onTableWheel($event) {
          setScrollBarTop(0, false, true, $event.deltaY > 0);
          $scope.$apply();
        }        
        
        function setScrollBarTop(y, isMoveHere, isMouseWheel, isForward) {
          // var yPosition = Math.max(0, Math.min($scope.vm.virtualScroll.sbHeightNum - $scope.vm.virtualScroll.sbThumbHNum, y));
          var scrollBarThumbTop = 0;
          var pageRowCount = $scope.vm.virtualScroll.rowsVisibleCount;
          var allRowsCount = $scope.vm.qHyperCube.qSize.qcy;
          
          if (!isMouseWheel) {
            $scope.vm.virtualScroll.isForwardScroll = y > $scope.vm.virtualScroll.sbThumbY;
          } else {
            $scope.vm.virtualScroll.isForwardScroll = isForward;
          }
          
          if ($scope.vm.virtualScroll.isForwardScroll) {
            $scope.vm.virtualScroll.forwardCount++;
            $scope.vm.virtualScroll.reverseCount = 0;
          } else {
            $scope.vm.virtualScroll.reverseCount++;
            $scope.vm.virtualScroll.forwardCount = 0;
          }
          
          if (isMoveHere) {
            $scope.vm.virtualScroll.sbThumbY = y;
            var rowIndex = Math.floor(y / $scope.vm.virtualScroll.sbHeight * $scope.layout.qHyperCube.qSize.qcy);
            $scope.vm.virtualScroll.rowIndex = rowIndex;
          } else {
            if ($scope.vm.virtualScroll.isForwardScroll) {
              $scope.vm.virtualScroll.sbThumbY += pageRowCount;
              $scope.vm.virtualScroll.rowIndex += pageRowCount;
            } else {
              $scope.vm.virtualScroll.sbThumbY -= (2 * pageRowCount);
              $scope.vm.virtualScroll.rowIndex -= (2 * pageRowCount);
            }
          
            if ($scope.vm.virtualScroll.sbThumbY < 0 ) {$scope.vm.virtualScroll.sbThumbY = 0};
            if ($scope.vm.virtualScroll.rowIndex < 0 ) {$scope.vm.virtualScroll.rowIndex = 0};
          }
          
          // scrollBarThumbTop = Math.max(0, Math.min($scope.vm.virtualScroll.sbHeight - $scope.vm.virtualScroll.sbThumbH, $scope.vm.virtualScroll.sbThumbY));
          scrollBarThumbTop = $scope.vm.virtualScroll.rowIndex / allRowsCount * ($scope.vm.virtualScroll.sbHeight - $scope.vm.virtualScroll.sbThumbH);
          scrollBarThumbTop = Math.max(0, Math.min(scrollBarThumbTop, ($scope.vm.virtualScroll.sbHeight - $scope.vm.virtualScroll.sbThumbH)));
          $scope.vm.virtualScroll.sbThumbY = scrollBarThumbTop;
          $scope.vm.virtualScroll.sbThumbYpx = scrollBarThumbTop + 'px';
          //console.log('setScrollBarTop: $scope.vm.virtualScroll', $scope.vm.virtualScroll);
          updateLayout();
        }        
        
        $scope.searchHeader = function($event, header) {
          if ($event.button != 0) {return; };
          $event.preventDefault();
          
          var searchFieldName = this.$parent.dim.qFallbackTitle;
          
          for (var i = 0; i < this.$parent.dim.qGroupFallbackTitles.length; i++) {
            if (this.$parent.dim.qGroupFallbackTitles[i] = searchFieldName) {
              searchFieldName = this.$parent.dim.qGroupFieldDefs[i]
              break;
            }
          }
          
          console.log('_app', _app);
          
          if ($scope.currentHeaderSearch == searchFieldName) {
            $scope.currentHeaderSearch = null;
            header.isSearchOpen = false;
            popUpSvc.close();
          } else {
            $scope.currentHeaderSearch = searchFieldName;
            header.isSearchOpen = true;
            console.log('$event.target', $event.target);
            console.log('$scope', $scope );
          
            if ($scope.qProductVersion == '4.0.X') {
              // HSBC qlik desktop
              popUpSvc.showField(
                $scope.currentHeaderSearch,
                _app.model.enigmaModel,
                {
                  $alignToElement: [$event.target],
                  collision: "flipfit",
                  direction: 'ltr'
                },
                {}, 
                function() {
                  // callback when popup closing(/clicked outside?)
                  // $scope.currentHeaderSearch = null
                  header.isSearchOpen = false;
                }
              )
            } else {
              // HSBC server install
              popUpSvc.showField(
                $scope.currentHeaderSearch,
                _app.model,
                {
                  $alignToElement: [$event.target],
                  collision: "flipfit",
                  direction: 'ltr'
                },
                null, 
                function() {
                  // callback when popup closing(/clicked outside?)
                  // $scope.currentHeaderSearch = null
                  header.isSearchOpen = false;
                }
              ) 
            }
          }
          
          $($event.target).toggleClass('columnSearchIconOpen');
        }
        
        $scope.headerClicked = function($event, index, header) {
          $event.preventDefault();
          
          if (header.isSearchOpen) {return;};
          
          if ($event.target.hasAttribute('search-col')) {return;}
          
          var qEffectiveInterColumnSortOrder = currentLayout.qHyperCube.qEffectiveInterColumnSortOrder;
          var isReverseSort = (index === qEffectiveInterColumnSortOrder[0]);
          
          if (isReverseSort) {
            var qPath = '';
            var qValue = '';
            if (index < currentLayout.qHyperCube.qDimensionInfo.length) {
              qPath = '/qHyperCubeDef/qDimensions/' + index + '/qDef/qReverseSort';
              qValue = JSON.stringify(!currentLayout.qHyperCube.qDimensionInfo[index].qReverseSort);
            } else {
              var measureIndex = index - currentLayout.qHyperCube.qDimensionInfo.length;
              qPath = '/qHyperCubeDef/qMeasures/' + measureIndex + '/qDef/qReverseSort';
              qValue = JSON.stringify(!currentLayout.qHyperCube.qMeasureInfo[measureIndex].qReverseSort);
            }
            $scope.backendApi.applyPatches([
              {
                'qPath': qPath,
                'qOp': 'replace',
                'qValue': qValue
              }
            ], false).then(function(){
            });
          } else {
            // remove this index from the array
            qEffectiveInterColumnSortOrder.splice(qEffectiveInterColumnSortOrder.indexOf(index), 1 ); 
            // insert this index at the beginning of the array
            qEffectiveInterColumnSortOrder.unshift(index);
            
            $scope.backendApi.applyPatches([
              {
                'qPath': '/qHyperCubeDef/qInterColumnSortOrder',
                'qOp': 'replace',
                'qValue': JSON.stringify(qEffectiveInterColumnSortOrder)
              }              
            ], false).then(function(){
            });
            // {
            //   'qOp': 'replace',
            //   'qPath': '/qHyperCubeDef/qDimensions/0/qDef/qSortCriterias/0/qSortByAscii',
            // /qHyperCubeDef/qMeasures/1/qSortBy/qSortByNumeric
            //   'qValue': '-1'
            // }
          }
        }
        
        $scope.getRowTrackBy = function(row) {
          var ret = '';
          for (var i = 0; i < currentLayout.qHyperCube.qDimensionInfo.length; i++) {
            ret += row[i].qElemNumber + '|';
          }
          return ret;
        }
        
        $scope.showTotalRow = function(position) {
          return currentLayout.props.totals.showTotals && (currentLayout.props.totals.position === position);
        }
        
        $scope.totalsRowStyle = function() {
          var ret = {};
          if (currentLayout.props.totals.totalsBackgroundColor) {
            ret['background-color'] = currentLayout.props.totals.totalsBackgroundColor;
          }  
          if (currentLayout.props.totals.totalsTextColor) {
            ret['color'] = currentLayout.props.totals.totalsTextColor;
          }        
          return ret;   
        }
        
        // need to work on useHTML !!!!
        $scope.getText = function(col, index) {
          var dimCount = currentLayout.dimCount; //  currentLayout.qHyperCube.qDimensionInfo.length;
          var qMeasure = currentLayout.qHyperCube.qMeasureInfo[index - dimCount];
          if (index >= dimCount) {
            if (qMeasure.useHTML) {
              return col.qText;
            }
          }
 
          return col.qText;
        }
        
        $scope.showDimensionColumn = function(measure) {
          return (showDimensionColumnObject(measure));
        }
        
        $scope.showMeasureColumn = function(measure) {
          return (showMeasureColumnObject(measure));
        }
        
        // local
        function showDimensionColumnIdx(index) {
          var qDimension = currentLayout.qHyperCube.qDimensionInfo[index];
          return (showDimensionColumnObject(qDimension));
        }  
        
        function showDimensionColumnObject(dimension) {
          return (!dimension.showMeasure || (dimension.showMeasure && dimension.qShowHide != '0'));
        }  
        
        function showMeasureColumnIdx(index) {
          var qMeasure = currentLayout.qHyperCube.qMeasureInfo[index];
          return (showMeasureColumnObject(qMeasure));
        }  
        
        function showMeasureColumnObject(measure) {
          return (!measure.showMeasure || (measure.showMeasure && measure.qShowHide != '0'));
        }  
        
        $scope.showDataColumn = function(index) {
          var dimCount = currentLayout.dimCount; // currentLayout.qHyperCube.qDimensionInfo.length;
          if (index < dimCount) { 
            return showDimensionColumnIdx(index);
          }
          var measureIndex = index - dimCount;
          return showMeasureColumnIdx(measureIndex);
        }   
        
        $scope.showDimColumnByIndex = function(index) {
          return (showDimensionColumnIdx(index));
        }  
        
        $scope.showMeaColumnByIndex = function(index) {
          return (showMeasureColumnIdx(index));
        }         
        
        $scope.showMeasureTotalValue = function(index) {
          var qMeasure = currentLayout.qHyperCube.qMeasureInfo[index];
          return (qMeasure.Showtotal == undefined ? true : qMeasure.Showtotal);
        }                  
        
        $scope.headerCellStyle = function(obj) {
          var ret = {};
          if (obj.adjustColumnWidth && obj.columnWidth) {
            ret['width'] = obj.columnWidth + 'px';
            ret['max-width'] = obj.columnWidth + 'px';
          } else {
            // get defaults - not coded for calculated widths yet
            ret['width'] = obj.columnWidth + 'px';
            ret['max-width'] = obj.columnWidth + 'px';            
          }
          if (currentLayout.props.header.fontBold) {
            ret['font-weight'] = 'bold';
          } else {
            ret['font-weight'] = 'normal';
          }
          if (currentLayout.props.header.fontItalic) {
            ret['font-style'] = 'italic';
          } else {
            ret['font-style'] = 'normal';
          }  
          if (currentLayout.props.header.textUnderlined) {
            ret['text-decoration'] = 'underline';
          } else {
            ret['text-decoration'] = 'none';
          }
          if (obj.titleTextAlignment) {
            ret['text-align'] = obj.titleTextAlignment;
          }
          return ret;
        }
        
        $scope.measureCellStyle = function(index) {
          return getCellStyle(currentLayout.qHyperCube.qMeasureInfo[index], true, null);
        }               
        
        function setRowStyle(row) {
          if (currentLayout.props.rows.rowsBackgroundColor) {
            row.style['backgroundColor'] = currentLayout.props.rows.rowsBackgroundColor;
          }
          
          if (currentLayout.props.rows.fontColour) {
            row.style['color'] = currentLayout.props.rows.fontColour;
          }            
          
          if (currentLayout.props.rows.fontBold) {
            row.style['fontWeight'] = 'bold';
          }
          
          if (currentLayout.props.rows.fontItalic) {
            row.style['fontStyle'] = 'italic';
          }  
          
          if (currentLayout.props.rows.textUnderlined) {
            row.style['textDecoration'] = 'underline';
          }     
          
          // if (currentLayout.props.rows.textalignment) {
          //   row.style['textAlign'] = currentLayout.props.rows.textalignment;
          // }                     
          
          if (currentLayout.props.rows.showBorder) {
            row.style['borderBottom'] = '1px #f2f2f2 solid';
          }
          
          if (!row.style['textAlign']) {row.style['textAlign'] = 'left';};
          if (!row.style['color']) {row.style['color'] = 'inherit'};
          if (!row.style['backgroundColor']) {row.style['backgroundColor'] = 'inherit'};  
          if (!row.style['fontWeight']) {row.style['fontWeight'] = 'normal';};
          if (!row.style['textDecoration']) {row.style['textDecoration'] = 'none'};
          if (!row.style['borderBottom']) {row.style['borderBottom'] = 'none'};           
          if (!row.style['fontStyle']) {row.style['fontStyle'] = 'normal'};
          
          row.style['showBorder'] = true;
        }
        
        function setUpCellStyles() {
          var cellObject = {}, qMatrixRow = {};
          var dimCount = currentLayout.qHyperCube.qDimensionInfo.length;
          var measureMaxValue = 0;
          var isShowValue = false;
          var qMatrix = currentLayout.grid; // currentLayout.qHyperCube.qDataPages[0].qMatrix;
          var measureIndex;
          var meaCount = currentLayout.qHyperCube.qMeasureInfo.length;
          var columnObject = {};
          var qDimensionInfoArray = currentLayout.qHyperCube.qDimensionInfo;
          var qMeasureInfoArray = currentLayout.qHyperCube.qMeasureInfo;
          
          for (var i = 0; i < qDimensionInfoArray.length; i++) {
            columnObject = qDimensionInfoArray[i];
            if (columnObject.isSearchable == undefined) {
              columnObject.isSearchable = currentLayout.qDef.isSearchable;
            }
            columnObject.headerText = (columnObject.customLabel != '' && columnObject.customLabel != undefined) ? columnObject.customLabel : columnObject.qFallbackTitle;
          }
          
          for (var i = 0; i < qMeasureInfoArray.length; i++) {
            columnObject = qMeasureInfoArray[i];
            columnObject.headerText = (columnObject.customLabel != '' && columnObject.customLabel != undefined) ? columnObject.customLabel : columnObject.qFallbackTitle;
          }          
          
          columnObject = {};
          
          for (var i = 0; i < qMatrix.length; i++) {
            qMatrixRow = qMatrix[i];
            qMatrixRow.style = {};
            
            setRowStyle(qMatrixRow);
            
            for (var j = 0; j < qMatrixRow.length; j++) {
              measureIndex = j - dimCount;
              cellObject = qMatrixRow[j];
              columnObject = j < dimCount ? qDimensionInfoArray[j] : qMeasureInfoArray[measureIndex];
              cellObject.style = {};
              cellObject.pbStyle = {};
              cellObject.style['showColumn'] = (!columnObject.showMeasure || (columnObject.showMeasure && columnObject.qShowHide != '0'));
              cellObject.style['showBorder'] = j < dimCount ? qDimensionInfoArray[j].showBorder : qMeasureInfoArray[measureIndex].showBorder;
              cellObject.style['cellRepresentation'] = columnObject.cellRepresentation === 'progressbar' ? 'pb' : 'txt';
            
              // cellObject.style.isSelected = cellObject.qState == 'S' && currentLayout.qSelectionInfo.qInSelections;
              if (columnObject.cellRepresentation === 'progressbar' && measureIndex >= 0) {
                if (cellObject.qAttrExps) {
                  if (cellObject.qAttrExps.qValues.length > 3) {
                    if (cellObject.qAttrExps.qValues[3].qText && cellObject.qAttrExps.qValues[3].qText != '') {
                      cellObject.pbStyle['backgroundColor'] = cellObject.qAttrExps.qValues[3].qText;
                    }              
                  }
                }
            
                if (!cellObject.pbStyle['backgroundColor']){
                  if (columnObject.progressBarColorPicker) {
                    if (columnObject.progressBarColorPicker.color) {
                      cellObject.pbStyle['backgroundColor'] = columnObject.progressBarColorPicker.color;
                    }  
                  } 
                }
            
                if (!cellObject.pbStyle['backgroundColor']){
                  if (columnObject.progressBarColor) {
                    if (columnObject.progressBarColor) {
                      cellObject.pbStyle['backgroundColor'] = columnObject.progressBarColor;
                    }  
                  }
                }
            
                if (cellObject.qNum !== 'NaN' && columnObject.maxValue >= cellObject.qNum) {
                  cellObject.pbStyle['width'] = (cellObject.qNum / columnObject.maxValue * 100).toFixed(0) + '%';
                }
              }
            
              if (columnObject.adjustColumnWidth && columnObject.columnWidth) {
                cellObject.style['width'] = columnObject.columnWidth + 'px';
                cellObject.style['maxWidth'] = columnObject.columnWidth + 'px';
              } else {
                // get defaults - not coded for calculated widths yet
                cellObject.style['width'] = columnObject.columnWidth + 'px';
                cellObject.style['maxWidth'] = columnObject.columnWidth + 'px';            
              }
            
              if (columnObject.textAlignment) {
                cellObject.style['textAlign'] = columnObject.textAlignment;
              } 
            
              if (columnObject.textColorPicker) {
                if (columnObject.textColorPicker.color) {
                  cellObject.style['color'] = columnObject.textColorPicker.color;
                }  
              } 
            
              if (columnObject.backgroundColorPicker) {
                if (columnObject.backgroundColorPicker.color) {
                  cellObject.style['backgroundColor'] = columnObject.backgroundColorPicker.color;
                }
              }
            
              if (cellObject.qAttrExps) {
                if (cellObject.qAttrExps.qValues.length > 0) {
                  if (cellObject.qAttrExps.qValues[0].qText && cellObject.qAttrExps.qValues[0].qText != '') {
                    cellObject.style['color'] = cellObject.qAttrExps.qValues[0].qText;
                  }              
                }
                if (cellObject.qAttrExps.qValues.length > 1) {
                  if (cellObject.qAttrExps.qValues[1].qText && cellObject.qAttrExps.qValues[1].qText != '') {
                    cellObject.style['backgroundColor'] = cellObject.qAttrExps.qValues[1].qText;
                  }              
                }              
              }
            
              if (!cellObject.style['textAlign']) {cellObject.style['textAlign'] = 'normal';};
              if (!cellObject.style['color']) {cellObject.style['color'] = 'inherit'};
              if (!cellObject.style['backgroundColor']) {cellObject.style['backgroundColor'] = 'inherit'};        
            }
          }
        }
        
        // slow
        function getCellStyle(columnObject, isForTotals, cellObject) {
          var ret = {};
        
          if (columnObject.adjustColumnWidth && columnObject.columnWidth) {
            ret['width'] = columnObject.columnWidth + 'px';
            ret['max-width'] = columnObject.columnWidth + 'px';
          } else {
            // get defaults - not coded for calculated widths yet
            ret['width'] = columnObject.columnWidth + 'px';
            ret['max-width'] = columnObject.columnWidth + 'px';            
          }
        
          if (columnObject.textAlignment) {
            ret['text-align'] = columnObject.textAlignment;
          }
          
          if (!isForTotals) {
            if (columnObject.textColorPicker) {
              if (columnObject.textColorPicker.color) {
                ret['color'] = columnObject.textColorPicker.color;
              }  
            } 
        
            if (columnObject.backgroundColorPicker) {
              if (columnObject.backgroundColorPicker.color) {
                ret['background-color'] = columnObject.backgroundColorPicker.color;
              }
            }
        
            if (cellObject.qAttrExps) {
              if (cellObject.qAttrExps.qValues.length > 0) {
                if (cellObject.qAttrExps.qValues[0].qText && cellObject.qAttrExps.qValues[0].qText != '') {
                  ret['color'] = cellObject.qAttrExps.qValues[0].qText;
                }              
              }
              if (cellObject.qAttrExps.qValues.length > 1) {
                if (cellObject.qAttrExps.qValues[1].qText && cellObject.qAttrExps.qValues[1].qText != '') {
                  ret['background-color'] = cellObject.qAttrExps.qValues[1].qText;
                }              
              }              
            }
            
          }
          return ret;          
        }
        
        $scope.headerStyle = function() {
          var ret = {}
 
          if (currentLayout.props.header.headerBackgroundColor) {
            ret['background-color'] = currentLayout.props.header.headerBackgroundColor;
          }
        
          if (currentLayout.props.header.fontColor) {
            ret['color'] = currentLayout.props.header.fontColor;
          }
        
          if (currentLayout.props.header.fontsize) {
            ret['font-size'] = currentLayout.props.header.fontsize;
          }
        
          if (currentLayout.props.header.fontfamily) {
            ret['font-family'] = currentLayout.props.header.fontfamily;
          }            
        
          if (currentLayout.props.header.fontBold) {
            ret['font-weight'] = 'bold';
          } else {
            ret['font-weight'] = 'normal';
          }
        
          if (currentLayout.props.header.fontItalic) {
            ret['font-style'] = 'italic';
          } else {
            ret['font-style'] = 'normal';
          }  
        
          if (currentLayout.props.header.textUnderlined) {
            ret['text-decoration'] = 'underline';
          } else {
            ret['text-decoration'] = 'none';
          }          
          // if (currentLayout.props.header.textalignment) {
          //   ret['text-align'] = currentLayout.props.header.textalignment;
          // }                                       
          return ret;
        }
        
        $scope.headerCellClass = function(obj) {
          var ret = [];
        
          if ((obj.showBorder == undefined && currentLayout.qDef.showBorder) || obj.showBorder) {
            ret.push('cellBorderRight');
          }
        
          if (obj.hasSelections) {
            ret.push('dimSelection');
          }          
          return ret;          
        }     
        
        $scope.meaCellClassByIndex = function(index) {
          return measureCellClass(index);          
        }
        
        function measureCellClass(index) {
          return currentLayout.qHyperCube.qMeasureInfo[index].showBorder;
        }                    
        
        $scope.cellClick = function(event, qElemNumber, row) {
          // if ($scope.layout.props.standardSelect) {return;}
          var evt = event;
          evt.stopPropagation();
        
          console.log('evt', evt);
        
          if (evt.currentTarget.hasAttribute('data-value') && evt.currentTarget.hasAttribute('data-dimension')) {
            var value = parseInt(evt.currentTarget.getAttribute('data-value'), 10);
            var dim = parseInt(evt.currentTarget.getAttribute('data-dimension'), 10);
            var isSelectedDimensionSelectable = false;
            var isSelectable = false;
        
            console.log('value', value);
        
            // check whether dimension is clicked,and then see if it is selectable
            if (dim < currentLayout.qHyperCube.qDimensionInfo.length) {
              isSelectedDimensionSelectable = currentLayout.qHyperCube.qDimensionInfo[dim].isSelectable == undefined ? currentLayout.qDef.isSelectable : currentLayout.qHyperCube.qDimensionInfo[dim].isSelectable;
            }
        
            if (!isSelectedDimensionSelectable || dim > currentLayout.qHyperCube.qDimensionInfo.length) 
            {
              for (var i = 0; i < currentLayout.qHyperCube.qDimensionInfo.length; i++) {
                isSelectable = currentLayout.qHyperCube.qDimensionInfo[i].isSelectable == undefined ? currentLayout.qDef.isSelectable : currentLayout.qHyperCube.qDimensionInfo[i].isSelectable;
        
                if (isSelectable) {
                  $scope.$parent.backendApi.selectValues(i, [row[i].qElemNumber], true);
                }
              }
            } else {
              $scope.$parent.backendApi.selectValues(dim, [value], true)
            }
          }
        }
        
        function waitForRender(callback) {
          console.log('waitForRender', currentLayout.qInfo.qId);
          setTimeout(function(){
            var t = $('#ccTable_' + currentLayout.qInfo.qId).get(0);
            if (t == undefined) {
              waitForRender(callback);
            } else {
              var position = t.getBoundingClientRect();
              if (position.top && position.left) {
                console.log('rendered!!');
                callback.call();
              } else {
                waitForRender(callback);
              }
            }
          });
        }

        function setupSortingDisplayFlags() {
          var sortByIndex = 0;
        
          if (currentLayout.qHyperCube.qEffectiveInterColumnSortOrder.length > 0) {
            sortByIndex = currentLayout.qHyperCube.qEffectiveInterColumnSortOrder[0];
          }
        
          var dimCount = currentLayout.qHyperCube.qDimensionInfo.length;
        
          if (sortByIndex < dimCount) {
            currentLayout.qHyperCube.qDimensionInfo[sortByIndex].isOrderedBy = true;
          } else {
            currentLayout.qHyperCube.qMeasureInfo[sortByIndex - dimCount].isOrderedBy = true;
          }
        }
        
        function setupProgressBarData() {
          // sort out progress bars, if any
          var dataCell = {}, qMatrixRow = {};
          var dimCount = currentLayout.qHyperCube.qDimensionInfo.length;
          var measureMaxValue = 0;
          var isShowValue = false;
        
          // get max value per progressbar measure, for later calcs of bar widths....
          var meaCount = currentLayout.qHyperCube.qMeasureInfo.length;
        
          for (var i = 0; i < meaCount; i++) {
            if (currentLayout.qHyperCube.qMeasureInfo[i].cellRepresentation == 'progressbar') {
              isShowValue = currentLayout.qHyperCube.qMeasureInfo[i].progressBarShowValue;
        
              for (var j = 0; j < $scope.vm.grid.length; j++) {
                qMatrixRow = $scope.vm.grid[j];
                dataCell = qMatrixRow[dimCount + i];
                dataCell.progressBarDisplayValue = isShowValue ? dataCell.qText : '&nbsp;';
        
                if (dataCell.qNum !== 'NaN' && measureMaxValue < dataCell.qNum) {
                  measureMaxValue = dataCell.qNum;
                }
              }
              currentLayout.qHyperCube.qMeasureInfo[i].maxValue = measureMaxValue;
            }
          }
        }
        
        // function selectionStateCallback(selectionState) {
        //   console.log('selectionState', selectionState);
        //   var fieldName = '', dimension = {}, fieldIndex = 0;
        //   for (var i = 0; i < selectionState.qSelectionObject.qSelections.length; i++) {
        //     fieldName = selectionState.qSelectionObject.qSelections[i].qField;
        //     for (var j = 0; j < currentLayout.qHyperCube.qDimensionInfo.length; j++) {
        //       dimension = currentLayout.qHyperCube.qDimensionInfo[j];
        //       if (dimension.qGroupFieldDefs.length > 0) {
        //         fieldIndex = dimension.qGroupFieldDefs.length - 1;
        //         if (dimension.qGroupFieldDefs[fieldIndex].replace('=[', '').replace(']','') == fieldName) {
        //           dimension.hasSelections = true;
        //         }
        //       }
        //     }            
        //   }
        // }
        
        function checkForData() {
          //var rowCount = currentLayout.qHyperCube.qDataPages[0].qMatrix.length;
          
          currentLayout.virtualScroll.rowIndex = currentLayout.virtualScroll.rowIndex < 0 ? 0 : currentLayout.virtualScroll.rowIndex;
          var currentRowIndex = currentLayout.virtualScroll.rowIndex;
          var qArea = currentLayout.virtualScroll.qArea;
          var qSize = currentLayout.qHyperCube.qSize;
          if ((currentRowIndex < qSize.qcy) && 
              (qArea.qTop > currentRowIndex || 
                currentRowIndex > (qArea.qTop + qArea.qHeight) || 
                (qArea.qTop + qArea.qHeight) < (currentRowIndex + currentLayout.virtualScroll.rowsVisibleCount - 1))) {
            // need a new data set

            var requestPage = [{
              qTop: currentRowIndex > (qSize.qcy - 150)  ? (qSize.qcy - 150) : currentRowIndex,
              qLeft: 0,
              qWidth: qSize.qcx,
              qHeight: 150
            }];
            
            if (requestPage[0].qTop < 0) { return false;}
            
            console.log('requestPage', requestPage);
            
            $scope.backendApi.getData(requestPage).then(function (data) {
              console.log('dataPages', data);
              var dataPages = getDataPages(data);
              // keep around 250 rows in cache, can we concatenate with current cache
              if ((qArea.qTop + qArea.qHeight == dataPages[0].qArea.qTop) && qArea.qHeight <= 300) {
                console.log('caching data');
                currentLayout.qHyperCube.qDataPages[0].qMatrix = currentLayout.qHyperCube.qDataPages[0].qMatrix.concat(dataPages[0].qMatrix);
                qArea.qHeight += dataPages[0].qArea.qHeight;
                currentLayout.virtualScroll.qArea = qArea;
                console.log('cached data', $scope.vm);
              } else {
                currentLayout.virtualScroll.qArea = dataPages[0].qArea;
                currentLayout.qHyperCube.qDataPages[0].qMatrix = dataPages[0].qMatrix;
              }
              processNewDataSlice();
            })
            
            return false;
          } 
          
          return true;
        }

        function getDataPages(data) {
          console.log('getDataPages: product version: ', $scope.qProductVersion);
          return data.qDataPages ? data.qDataPages : data; // handles different qlik versions...
        }
        
        function processNewDataSlice() {
          var qArea = currentLayout.virtualScroll.qArea;
          var qSize = currentLayout.qHyperCube.qSize;
          var qMatrix = currentLayout.qHyperCube.qDataPages[0].qMatrix;
          var rowsVisibleCount = currentLayout.virtualScroll.rowsVisibleCount;
          var currentRowIndex = currentLayout.virtualScroll.rowIndex;
          
          if (currentRowIndex > qSize.qcy) {
            currentRowIndex = qSize.qcy;
            currentLayout.virtualScroll.rowIndex = currentRowIndex;
          }
          
          var offsetIndex = currentRowIndex - qArea.qTop;
          
          console.log('processNewDataSlice: offsetIndex:1', offsetIndex);
          console.log('processNewDataSlice: currentLayout.virtualScroll', currentLayout.virtualScroll);
          
          // make sure last slice gets moved up into visible rows
          if (currentRowIndex > (qSize.qcy - rowsVisibleCount)) {
            offsetIndex = qArea.qHeight - rowsVisibleCount;
            console.log('processNewDataSlice: offsetIndex:2', offsetIndex);
          }
          
          currentLayout.grid = qMatrix.slice(offsetIndex, offsetIndex + Math.max(10, rowsVisibleCount) + 10);
          
          setupProgressBarData();
          setUpCellStyles();
          setupSortingDisplayFlags();
          
          console.log('processNewDataSlice: finish', currentLayout);

          $scope.vm = currentLayout;
        }

        function updateLayout() {
          if (checkForData()){
            processNewDataSlice();
          }
        }

        function refresh() {
          console.log('refresh:$scope', $scope);
          console.log('refresh: product version: ', $scope.qProductVersion);
          var isRefresh = true;
          
          // let's just make sure all our meta data is preserved..
          //console.log('refresh:2');
          if ($scope.layout.extensionMeta) {
            if ($scope.layout.extensionMeta.author !== defaults.extensionMeta.author) {
              // console.log('defaults.extensionMeta', $scope.layout.extensionMeta);
              //console.log('refresh:3');
              $scope.layout.extensionMeta = angular.copy(defaults.extensionMeta);
            }
          }
          
          console.log('refresh:4');
          if ($scope.layout.qSelectionInfo.qInSelections) {
            console.log('refresh: qInSelections =  true');
            // make sure we have the same data set for wherever the user has scrolled to.
            //if ($scope.layout.qHyperCube.qDataPages[0].qArea.qTop != currentLayout.virtualScroll.qArea.qTop) {
              isRefresh = false;
              console.log('refresh: isRefresh = false');
            //}
          }
          
          if (isRefresh) {
            if (!angular.equals($scope.layout, currentLayout)) {
              currentLayout =  JSON.parse(JSON.stringify($scope.layout)); // angular.copy($scope.layout);
              console.log('refresh:5.2');
              console.log('currentLayout.qSelectionInfo.qInSelections', currentLayout.qSelectionInfo.qInSelections);
            } else {
              console.log('refresh:return');
              return;
            }
            
            if (!currentLayout.virtualScroll) { currentLayout.virtualScroll = {} };
          
            currentLayout.virtualScroll.qArea = currentLayout.qHyperCube.qDataPages[0].qArea;
            currentLayout.virtualScroll.sbThumbYpx = '0px';
            currentLayout.virtualScroll.sbThumbY = 0;
            currentLayout.virtualScroll.rowIndex = 0;
            currentLayout.virtualScroll.rowsVisibleCount = 0;
            currentLayout.virtualScroll.forwardCount = 0;
            currentLayout.virtualScroll.reverseCount = 0;
          
            if (!$scope.layout.qSelectionInfo.qInSelections) {
              currentLayout.virtualScroll.selected = [];
            }
            
            currentLayout.dimCount = currentLayout.qHyperCube.qDimensionInfo.length;
            // $scope.layout.props.standardSelect = $scope.layout.props.standardSelect == undefined ? false : $scope.layout.props.standardSelect;            
          }

          updateLayout();

          waitForRender(function() {
            var hoverStyle = '<style>.rowHighlight:hover {';
            var tdOverride = '.rowHighlight:hover > td {';
            
            if (currentLayout.props.rows.highlightRows) {
              console.log('add hover style: start');
              if (currentLayout.props.rows.rowHighlightColour) {
                hoverStyle += 'background-color: ' + currentLayout.props.rows.rowHighlightColour + '!important;';
                tdOverride += 'background-color: ' + currentLayout.props.rows.rowHighlightColour + '!important;';
              } 
              if (currentLayout.props.rows.rowHoverFontColour) {
                hoverStyle += 'color: ' + currentLayout.props.rows.rowHoverFontColour + '!important;';
                tdOverride += 'color: ' + currentLayout.props.rows.rowHoverFontColour + '!important;';
              }
          
              hoverStyle += '}' + tdOverride + '}</style>';
              $('#ccTable_' + currentLayout.qInfo.qId).append(hoverStyle);
              console.log('add hover style: end');
            } 
            
            document.getElementById('ccTableBody_'  + currentLayout.qInfo.qId).addEventListener('wheel', onTableWheel);
            
            if ($scope.$parent) {
              $scope.$parent.component.resizeTable($scope.vm);
              if (!$scope.layout.qSelectionInfo.qInSelections) {
                $element.find('.selectable').toggleClass('selected', false);
              } else {
                var selectedObject = {};
                if (currentLayout.virtualScroll.selected) {
                  for (var i = 0; i < currentLayout.virtualScroll.selected.length; i++) {
                    selectedObject = currentLayout.virtualScroll.selected[i];
                    $element.find("[data-dimension='" + selectedObject.dim + "'][data-value='" + selectedObject.value + "']").toggleClass('selected', true)
                  }
                }
              }              
            }
          })

          // $element.off('qv-activate', '.selectable')
          // if ($scope.layout.props.standardSelect) {
          //   $element.on('qv-activate', '.selectable', function() {
          //     if (this.hasAttribute('data-value')) {
          //       var value = parseInt(this.getAttribute('data-value'), 10);
          //       var dim = parseInt(this.getAttribute('data-dimension'), 10);
          //       if (!currentLayout.virtualScroll.selected) {
          //         currentLayout.virtualScroll.selected = [];
          //       }
          //       currentLayout.virtualScroll.selected.push({ dim: dim, value: value});
          //       $scope.selectValues(dim, [value], true)
          //       $element.find("[data-dimension='" + dim + "'][data-value='" + value + "']").toggleClass('selected')
          //     }
          //   })
          // }
        }
        
        refresh();
      }] 
    };
} );
